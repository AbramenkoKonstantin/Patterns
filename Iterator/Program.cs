using System;
/// <summary>
/// Тип - поведенческий 
/// 
/// Описание - абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта без раскрытия его внутренней структуры.
/// 
/// Назначение - даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
/// 
/// Метафора:
/// Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. 
/// Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.
/// Если у вас ограниченный бюджет — не беда. 
/// Вы можете воспользоваться виртуальным гидом, скачанным на телефон, который позволит отфильтровать только интересные вам точки. 
/// А можете плюнуть и нанять локального гида, который хоть и обойдется в копеечку, но знает город как свои пять пальцев, 
/// и сможет посвятить вас во все городские легенды.
/// Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции. 
/// Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.
/// 
/// Потенциальные проблемы:
/// 1) Не оправдан, если можно обойтись простым циклом.
/// 2) Использовать их стоит только тогда, когда есть необходимость в полиморфизме. 
/// В противном случае применяйте конкретные итераторы, которые вполне можно распределять в стеке.
/// </summary>

namespace Iterator
{
    class Program
    {
        static void Main(string[] args)
        {
            SquareCollection sc = new SquareCollection(10);
            foreach (var item in sc)
            {
                Console.WriteLine(item);
            }
            Console.ReadKey();
        }
    }
}
